/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.location;

import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;
//import android.os.SystemClock;
//import android.util.Printer;
//import android.util.TimeUtils;

//import java.text.DecimalFormat;
//import java.util.StringTokenizer;

/**
 * A data class representing a geographic location.
 *
 * <p>A location can consist of a latitude, longitude, timestamp,
 * and other information such as bearing, altitude and velocity.
 *
 * <p>All locations generated by the {@link LocationManager} are
 * guaranteed to have a valid latitude, longitude, and timestamp
 * (both UTC time and elapsed real-time since boot), all other
 * parameters are optional.
 */
public class LocAcceInfo implements Parcelable {
    

    private int axis;
    private float valueX;
    private float valueY;
    private float valueZ;
    private int interval;
    private long tickTime;

	public LocAcceInfo() {
    }

    /**
     * Construct a new LocAcceInfo object that is copied from an existing one.
     */
    public LocAcceInfo(LocAcceInfo l) {
        set(l);
    }

    /**
     * Sets the contents of the location to the values from the given LocAcceInfo.
     */
    public void set(LocAcceInfo l) {
        axis = l.axis;
        valueX = l.valueX;
        valueY = l.valueY;
        valueZ = l.valueZ;
        interval = l.interval;
        tickTime = l.tickTime;
    }

    /**
     * Clears the contents of the LocAcceInfo.
     */
    public void reset() {
        axis = 0;
        valueX = 0;
        valueY = 0;
        valueZ = 0;
        interval = 0;
        tickTime = 0;
    }

	public int getAxis() {
        return axis;
    }
	
    public void setAxis(int ax) {
        axis = ax;
    }

	public float getX() {
        return valueX;
    }
	
    public void setX(float x) {
        valueX = x;
    }

	public float getY() {
        return valueY;
    }
	
    public void setY(float y) {
        valueY = y;
    }

	public float getZ() {
        return valueZ;
    }
	
    public void setZ(float z) {
        valueZ = z;
    }

	public int getInterval() {
        return interval;
    }
	
    public void setInterval(int inter) {
        interval = inter;
    }

    
    /**
     * Return the UTC time of this fix, in milliseconds since January 1, 1970.
     *
     * <p>Note that the UTC time on a device is not monotonic: it
     * can jump forwards or backwards unpredictably. So always use
     * {@link #getElapsedRealtimeNanos} when calculating time deltas.
     *
     * <p>On the other hand, {@link #getTime} is useful for presenting
     * a human readable time to the user, or for carefully comparing
     * location fixes across reboot or across devices.
     *
     * <p>All locations generated by the {@link LocationManager}
     * are guaranteed to have a valid UTC time, however remember that
     * the system time may have changed since the location was generated.
     *
     * @return time of fix, in milliseconds since January 1, 1970.
     */
    public long getTime() {
        return tickTime;
    }

    /**
     * Set the UTC time of this fix, in milliseconds since January 1,
     * 1970.
     *
     * @param time UTC time of this fix, in milliseconds since January 1, 1970
     */
    public void setTime(long time) {
        tickTime = time;
    }

    

    @Override
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append("LocAcceInfo[");
		s.append(" axis=").append(axis);
        s.append(" valueX=").append(valueX);
		s.append(" valueY=").append(valueY);
		s.append(" valueZ=").append(valueZ);
		s.append(" interval=").append(interval);
		s.append(" tickTime=").append(tickTime);
        
        s.append(']');
        return s.toString();
    }



    public static final Parcelable.Creator<LocAcceInfo> CREATOR =
        new Parcelable.Creator<LocAcceInfo>() {
        @Override
        public LocAcceInfo createFromParcel(Parcel in) {
            LocAcceInfo l = new LocAcceInfo();
            

            l.axis = in.readInt();
            l.valueX = in.readFloat();
			l.valueY = in.readFloat();
			l.valueZ = in.readFloat();
			l.interval = in.readInt();
			l.tickTime = in.readLong();

            return l;
        }

        @Override
        public LocAcceInfo[] newArray(int size) {
            return new LocAcceInfo[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel parcel, int flags) {

        parcel.writeInt(axis);
		parcel.writeFloat(valueX);
		parcel.writeFloat(valueY);
		parcel.writeFloat(valueZ);
        parcel.writeInt(interval);
        parcel.writeLong(tickTime);
    }

    
}
